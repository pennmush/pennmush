& EVENTS
& EVENT
  PennMUSH Events are hardcoded events that may or may not be caused by players. The Event system lets administrators designate an object as an event handler (using the "event_handler" config option). The
  event_handler object will then have attributes triggered, with arguments, on specified events.

  To use the PennMUSH Event System:

  > @create Event Handler
  > @config/set event_handler=[num(Event Handler)]
  > &<event name> Event Handler=<action list>

  You will very likely want to set the event_handler option in your mush.cnf file to ensure it survives over dumps and is actively receiving events even during startup.

  The enactor of an event is either:
    1) The executor that caused it, or
    2) #-1 for system events without an executor.

  For a list of events and their arguments, see 'help event list'.

  For some examples of using events, see 'help event examples'.
& EVENT EXAMPLES
  Suppose you want random dbsave messages:
  > &DUMP`COMPLETE Event Handler=@config/set dump_complete=SAVE: [v(randword(lattr(me/dumpmsg`*)))]
  > &DUMPMSG`NOTHING Event=The Database has been saved, nothing to see here.
  > &DUMPMSG`GRETZKY Event=The Database saves, but Gretzky scores!
  > &DUMPMSG`GEICO Event=The Database saved 15% by switching to Geico!
  > @dump
  SAVE: The Database has been saved, nothing to see here.
  > @dump
  SAVE: The Database saved 15% by switching to Geico!

  Or admin want to be notified when a player connect attempt fails.
  > @set Event=wizard
  > &SOCKET`LOGINFAIL Event=@wizwall/emit On descriptor '%0' from IP '%1' a failed connect attempt to '%4': '%3'
   (Later, a player attempts to log in as #1)
  Broadcast: [Event Handler]: On descriptor 3, from IP '127.0.0.1', a failed connect attempt to '#1': 'invalid password'

  For more examples, see 'help event examples2'.
& EVENT EXAMPLES2
  Suppose you want @pcreated players to be powered builder, set shared and zonelocked to roys, but players created at the connect screen to not be.
  > @set Event=wizard
  > &PLAYER`CREATE Event=@assert %# ; @pemit %#=Auto-Setting [name(%0)] Builder and shared ; @power %0=builder ; @lock/zone %0=FLAG^ROYALTY ; @set %0=shared
  > @pcreate Grid-BC
  Auto-Setting Grid-BC Builder and Shared

  The Event Handler object, since it's handling so many events, may become cluttered with attributes. We recommend using @trigger and @include to separate events to multiple objects.
& EVENT LIST
  Event names are of the format <type>`<event>. The 'type' is used simply to group similar events together for help.

  Event syntax in the help is of the form:
  <eventgroup>`<eventname> (What is passed as %0, %1, ... %9)

  The following event types and events have been added to PennMUSH. To see the help for them, type 'help event <type>'.

  dump: dump`5min, dump`1min, dump`complete, dump`error
  db: db`dbck, db`purge, db`warnings
  log: log`err, log`cmd, log`conn, log`trace, log`check, log`huh
  object: object`create, object`destroy, object`move, object`rename, object`flag
  sql: sql`connect, sql`connectfail, sql`disconnect
  signal: signal`usr1, signal`usr2
  player: player`create, player`connect, player`disconnect, player`inactivity
  socket: socket`connect, socket`disconnect, socket`loginfail, socket`createfail
& EVENT DB
  db`dbck: Run after the regular database consistency check.
  db`purge: Run after the regular purging of destroyed objects.
  db`wcheck: Run after the regular @warnings check.
  
  Note: These events are only triggered after the automatic scheduled checks, and not if someone manually runs @dbck, @purge or @wcheck.
& EVENT DUMP
  dump`5min (Original message, isforking)
      Database save will occur in 5 minutes.
  dump`1min (Original message, isforking)
      Database save will occur in 1 minute.
  dump`complete (Original message, wasforking)
      Database save has completed.
  dump`error (Error message, wasforking, exit_status)
      Database save failed! You might want this to alert any admin on.
      exit_status has different meanings in forking and non-forking dumps.
      In forking: exit_status is a string, either "SIGNAL <int>" or "EXIT <int>". SIGNAL <int> refers to the mush process receiving error message via signal while EXIT <int> refers to mush process exiting abnormally.
      In nonforking: exit_status is "PERROR <string>" - string being the error message returned by strerror(errno). If you are seeing errors on dbsave, we recommend setting forking_dump to 0, as nonforking dumps have more verbose error messages.

  The standard messages shown on dumps are still displayed when these events are set. To disable the standard message, set them to empty strings via @config or in mush.cnf.
& EVENT LOG
  Events in the log tree get triggered whenever the game logs any information to a log file (Either because of @log, or something else happening.) They all get passed a single argument, the message being logged.

  log`err
     Errors and the general catch-all.
  log`cmd
     Logged commands.
  log`wiz
     Logged wizard activity.
  log`conn
     Connection notifications.
  log`trace
     Memory tracking notifications.
  log`check
     Save-releated log messages.
  log`huh
     Commands that generate huh messages.
& EVENT OBJECT
  object`create (new objid, cloned-from)
      Triggered on the creation of any object except player. If it was created using @clone, then <cloned-from> will be a objid. Otherwise <cloned-from> will be null.

  object`destroy (objid, origname, type, owner, parent, zone)
      Triggered _after_ the object is totally destroyed. Passed arguments are former objid, name, type, owner, etc. Enactor is always #-1, so use former owner.

  object`move (objid, newloc, origloc, issilent, cause)
      Triggered after the object is moved, @tel'd, or otherwise sent to a new location. If <issilent> is 1, then the object was moved using @tel/silent.

  object`rename (objid, new name, old name)
      Triggered when any object is renamed.
      
  object`flag (objid of object with flag, flag name, type, setbool, setstr)
      Triggered when a flag or power which has the "event" restriction is set or cleared. <type> is one of FLAG or POWER. <setbool> is 1 if the flag/power is being set, and 0 if it's being cleared. <setstr> is either "SET" or "CLEARED".
    Example:
      &OBJECT`FLAG event handler=@cemit Admin=capstr(lcstr(%2)) %1 [lcstr(%4)] on [name(%0)] by %n.

& EVENT SQL
  sql`connect (platform)
      Triggered on successful connect to the SQL database. <platform> is 'mysql', 'postgresql' or 'sqlite3'.

  sql`connectfail (platform, error message)
      Triggered on unsuccessful connect to the SQL database.

  sql`disconnect (platform, error message)
      Triggered if SQL disconnects for any reason. Usually not a worry since Penn will auto-reconnect if it can.
& EVENT SIGNAL
No arguments are passed to these events.

  signal`usr1: Triggered when the PennMUSH process receives a "kill -USR1"

  signal`usr2: Triggered when the PennMUSH process receives a "kill -USR2"

  If these attributes exist, then penn will NOT perform what it usually does when it receives a signal. In effect, these override Penn's default actions.

  To mimic old behaviour:
  &SIGNAL`USR1 Event Handler=@nspemit/list lwho()=GAME: Reboot w/o disconnect from game account, please wait. ; @shutdown/reboot
  &SIGNAL`USR2 Event Handler=@dump
& EVENT PLAYER
  player`create (objid, name, how, descriptor, email)
      Triggered when a player is created. If the player was @pcreated, then %# will be the person who did the @pcreate. If player was created by using 'create' at the connect screen, then %# will be #-1 and <descriptor> will be non-null. <how> is one of: "pcreate", "create" or "register". If created using 'register', <email> will be set appropriately.

  player`connect (objid, number of connections, descriptor)
      Similar to @aconnect, but for events, and so you can use descriptor.

  player`disconnect (objid, number of remaining connections, hidden?, cause of disconnection, ip, descriptor, conn() secs, idle() secs, recv bytes/sent bytes/command count)
      Similar to @adisconnect, but for event system, and with more information available.
  player`inactivity: Triggered when idle players are disconnected. Only run if at least one player gets idlebooted (Or auto-hidden), not at every inactivity check.
& EVENT SOCKET
  socket`connect (descriptor, ip)
      Triggered when a socket first connects to the port. Using both this and player`connect could be spammy. This happens when a connecting socket sees the connect screen.

  socket`disconnect (former descriptor, former ip, cause of disconnection, recv bytes/sent bytes/command count)
      Triggered when a socket disconnects. Using this and player`disconnect could be spammy.

  socket`loginfail (descriptor, IP, count, reason, playerobjid, name)
      Triggered when a login attempt fails. <count> is the number of fails in the past 10 minutes. If used in conjuction with the config option connect_fail_limit, then any failures after the limit is reached will NOT trigger socket`loginfail. If the connect is a failed attempt to log into a valid player, <playerobjid> will be set to that objid. Otherwise it will be set to #-1. <name> is the name the connection attempted to connect with, and is only set when <playerobjid> is #-1.

  socket`createfail (descriptor, ip, count, reason, name[, error])
      Triggered when a player create attempt fails. <count> is the # of fails caused by this ip. If the failure is from an attempt to register a player via email, the error code of the mailer program is provided as <error>.

    A sitelock rule with deny_silent will not trigger socket`createfail or socket`createfail.
& HTTP
  PennMUSH now supports HTTP requests reaching its mush port. It is very low level,
  and a little tricky to understand.

  When an HTTP request hits the PennMUSH port, PennMUSH invisibly logs in to
  the HTTP Handler player (@config http_handler), and executes an
  @include me/<method>. e.g: @include me/get.

  %0 will be the pathname, e.g: "/", "/rest/path", etc.

  %1 will be the body of the request. If it's json, use json_query to deal with it.
     If it's form-encoded, look at help formdecode()

  Anything sent to the HTTP Handler player during evaluation of this code is
  included in the body sent to the HTTP Client. There is a maximum size of
  BUFFER_LEN for the body of the response.

  To modify the response headers, use the command "@respond"

  Continued in: "help http2"
& HTTP2
  To use PennMUSH HTTP Handler:

  > @pcreate HTTPHandler
  > @config/set http_handler=[num(*HTTPHandler)]
  > &GET *HTTPHandler=say Somebody tried to HTTP GET %0!

  You will very likely want to set the http_handler option in your mush.cnf
  file to ensure it survives over reboots and is actively receiving events even
  during startup.

  By default, PennMUSH will respond with a 404 NOT FOUND. You will need to
  use @respond to control what is sent to the client.

  For some examples of using events, see 'help http examples'.

  See also: @respond, formdecode(), json_query(), urlencode(), urldecode(),
            urlunpack()
& @RESPOND
  @respond <code> <text>
  @respond/type <content-type>
  @respond/header <name>: <value>

  Within the context of an HTTP Player connection, @respond is used to modify
  the headers sent back to the HTTP client.

  If an HTTP Handler isn't set, or a given method attribute doesn't exist on the
  http handler object, Penn will default to responding as if only mud_url is
  set.

  If an attribute exists, Penn defaults to 200 OK, and Content-Type "text/plain"

  @respond <code> <text> changes the 1st line sent to the client (200 OK)
  @respond/type <text> replaces the current Content-Type header. (text/plain)
  @respond/header <name>: <value> adds a new Header.

  @respond commands are _not_ required to be run before any output is sent to
  the player. For Content-Length purposes, Penn buffers all output before the
  @include finishes.

  See examples in "help @respond2". HTTP limitations in "help @respond3"

& @RESPOND2
  @respond examples:

  To modify the response code:

  > @respond 200 OK
  > @respond 404 Not Found

  To change the Content Type:

  > @respond/type application/json
  > @respond/type text/html

  Note that @respond/type is not syntactic sugar for "@respond/header Content-Type".
  An HTTP @respond typically should only have one content-type, and
  @respond/type overrides it. Using @respond/header to add Content-Type will
  create a second header named Content-Type.

  Add Headers:
  > @respond/header X-Powered-By=MUSHCode
  > @respond/header {Set-Cookie: name=Bob; Max-Age=3600; Version=1}

  Adding a Content-Length header is not allowed - PennMUSH calculates it from
  the output before sending.
& @RESPOND3
  To vaguely comply with most HTTP requirements:

  @respond <code> <text>
      <code> must be 3 digits, followed by a space, then printable ascii text.
             Total length must be < 40 characters.
             This will be prepended by HTTP/1.1 when sent back to
             the client.

  @respond/header <name>: <value>
      <name> must be printable ascii characters (No accents, no %r)
      <value> must be printable, but accents allowed (No %r)

  @respond/type <ctype>
      <ctype> should be alphanumeric, +, ., /, -. HTTP/1.1 does allow for
              parameters (text/plain; content-encoding=...), so we don't
              enforce anything at present except printability().

& HTTP EXAMPLES
  There are a number of HTTP Examples.

  Example HTTP Handlers all assume the following:

  > @pcreate HTTPHandler=digest(md5,rand())
  > @config/set http_handler=pmatch(HTTPHandler)

  For the basic lowest level examples: "help http simple"

  For using urls and url parameters: "help http get"

  For handling POSTs and POST data: "help http post"

  For a basic, programmable REST interface: "help http REST"

  For an expandable http router: "help http router"
& HTTP SIMPLE
  The examples on this page are all simple, single-result handlers.

  Return the output of WHO to any GET request:

  > &GET *HTTPHandler=WHO

  Return a JSON array of users to any GET request

  > &LIST_TO_JSON`FOLD *HTTPHandler=json_mod(%0,insert,$\[[json_query(%0,size)]\],json(string,%1))
  > &LIST_TO_JSON *HTTPHandler=fold(list_to_json`fold,%0,\[\],%1)
  > &NAMES *HTTPHandler=u(list_to_json,map(#apply/name,mwho(),%b,^),^)
  > &GET *HTTPHandler=@respond/type application/json ; think u(names)

  Whenever a POST is performed, say the path and body.

  > &POST *HTTPHandler=say POST attempted at %0: %1

& HTTP GET
  These examples cover blah blah UPDATE ME
