/**
 * \file markup.c
 *
 * \brief Markup handling in PennMUSH strings.
 *
 *
 */

#include "config.h"

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <limits.h>
#include "copyrite.h"
#include "conf.h"
#include "case.h"
#include "pueblo.h"
#include "parse.h"
#include "externs.h"
#include "ansi.h"
#include "mymalloc.h"
#include "log.h"
#include "game.h"
#include "confmagic.h"

#define ANSI_BEGIN   "\x1B["
#define ANSI_FINISH  "m"

/* COL_* defines */

#define CBIT_HILITE      (1)     /**< ANSI hilite attribute bit */
#define CBIT_INVERT      (2)     /**< ANSI inverse attribute bit */
#define CBIT_FLASH       (4)     /**< ANSI flash attribute bit */
#define CBIT_UNDERSCORE  (8)     /**< ANSI underscore attribute bit */

#define COL_NORMAL      (0)     /**< ANSI normal */
#define COL_HILITE      (1)     /**< ANSI hilite attribute value */
#define COL_UNDERSCORE  (4)     /**< ANSI underscore attribute value */
#define COL_FLASH       (5)     /**< ANSI flag attribute value */
#define COL_INVERT      (7)     /**< ANSI inverse attribute value */

#define COL_BLACK       (30)    /**< ANSI color black */
#define COL_RED         (31)    /**< ANSI color red */
#define COL_GREEN       (32)    /**< ANSI color green */
#define COL_YELLOW      (33)    /**< ANSI color yellow */
#define COL_BLUE        (34)    /**< ANSI color blue */
#define COL_MAGENTA     (35)    /**< ANSI color magenta */
#define COL_CYAN        (36)    /**< ANSI color cyan */
#define COL_WHITE       (37)    /**< ANSI color white */

/* Now the code */

static int write_ansi_letters(const ansi_data *cur, char *buff, char **bp);
static int safe_markup(char const *a_tag, char *buf, char **bp, char type);
static int
 safe_markup_cancel(char const *a_tag, char *buf, char **bp, char type);
static int escape_marked_str(char **str, char *buff, char **bp);

const char *is_allowed_tag(const char *s, unsigned int len);

static const ansi_data ansi_null = { 0, 0, 0, 0 };

/* ARGSUSED */
FUNCTION(fun_stripansi)
{
  char *cp;
  cp = remove_markup(args[0], NULL);
  safe_str(cp, buff, bp);
}

FUNCTION(fun_ansigen)
{
  char *ptr;
  if (nargs < 1)
    return;
  for (ptr = args[0]; *ptr; ptr++) {
    switch (*ptr) {
    case '<':
      safe_chr(TAG_START, buff, bp);
      break;
    case '>':
      safe_chr(TAG_END, buff, bp);
      break;
    case '&':
      safe_chr(ESC_CHAR, buff, bp);
      break;
    default:
      safe_chr(*ptr, buff, bp);
    }
  }
}

/* ARGSUSED */
FUNCTION(fun_ansi)
{
  ansi_data colors;
  char *save = *bp;
  char *p;
  int i;

  if (!*args[1])
    return;

  /* Populate the colors struct */
  define_ansi_data(&colors, args[0]);

  /* If there are no colors designated at all, then just return args[1]. */
  if (!(colors.bits || colors.offbits || colors.fore || colors.back)) {
    safe_strl(args[1], arglens[1], buff, bp);
    return;
  }

  /* Write the colors to buff */
  if (write_ansi_data(&colors, buff, bp)) {
    *bp = save;
    return;
  }

  /* If the contents overrun the buffer, we
   * place an ANSI_ENDALL tag at the end */
  if (safe_str(args[1], buff, bp) || write_ansi_close(buff, bp)) {
    p = buff + BUFFER_LEN - 6;  /* <c/a> */
    for (i = 10; i > 0 && *p != TAG_START; i--, p--) ;
    if (i > 0) {
      /* There's an extant tag, let's just replace that. */
      *bp = p;
      safe_str(ANSI_ENDALL, buff, bp);
    } else {
      *bp = buff + BUFFER_LEN - 6;
      safe_str(ANSI_ENDALL, buff, bp);
    }
  }
}

/* File generated by gperf */
#include "htmltab.c"

/* ARGSUSED */
FUNCTION(fun_html)
{
  if (!Wizard(executor))
    safe_str(T(e_perm), buff, bp);
  else
    safe_tag(args[0], buff, bp);
}

/* ARGSUSED */
FUNCTION(fun_tag)
{
  int i;
  if (!Can_Pueblo_Send(executor)
      && !is_allowed_tag(args[0], arglens[0])) {
    safe_str("#-1", buff, bp);
    return;
  }
  safe_chr(TAG_START, buff, bp);
  safe_chr(MARKUP_HTML, buff, bp);
  safe_strl(args[0], arglens[0], buff, bp);
  for (i = 1; i < nargs; i++) {
    if (ok_tag_attribute(executor, args[i])) {
      safe_chr(' ', buff, bp);
      safe_strl(args[i], arglens[i], buff, bp);
    }
  }
  safe_chr(TAG_END, buff, bp);
}

/* ARGSUSED */
FUNCTION(fun_endtag)
{
  if (!Can_Pueblo_Send(executor) && !is_allowed_tag(args[0], arglens[0]))
    safe_str("#-1", buff, bp);
  else
    safe_tag_cancel(args[0], buff, bp);
}

/* ARGSUSED */
FUNCTION(fun_tagwrap)
{
  if (!Can_Pueblo_Send(executor) && !is_allowed_tag(args[0], arglens[0]))
    safe_str("#-1", buff, bp);
  else {
    if (nargs == 2)
      safe_tag_wrap(args[0], NULL, args[1], buff, bp, executor);
    else
      safe_tag_wrap(args[0], args[1], args[2], buff, bp, executor);
  }
}

/** A version of strlen that ignores ansi and HTML sequences.
 * \param p string to get length of.
 * \return length of string p, not including ansi/html sequences.
 */
int
ansi_strlen(const char *p)
{
  int i = 0;

  if (!p)
    return 0;

  while (*p) {
    if (*p == TAG_START) {
      while ((*p) && (*p != TAG_END))
        p++;
    } else if (*p == ESC_CHAR) {
      while ((*p) && (*p != 'm'))
        p++;
    } else {
      i++;
    }
    p++;
  }
  return i;
}

/** Returns the apparent length of a string, up to numchars visible
 * characters. The apparent length skips over nonprinting ansi and
 * tags.
 * \param p string.
 * \param numchars maximum size to report.
 * \return apparent length of string.
 */
int
ansi_strnlen(const char *p, size_t numchars)
{
  size_t i = 0;

  if (!p)
    return 0;
  while (*p && numchars > 0) {
    if (*p == ESC_CHAR) {
      while ((*p) && (*p != 'm')) {
        p++;
      }
    } else if (*p == TAG_START) {
      while ((*p) && (*p != TAG_END)) {
        p++;
      }
    } else
      numchars--;
    i++;
    p++;
  }
  return i;
}

/** Compare two strings, ignoring all ansi and html markup from a string.
 *  Is *NOT* locale safe (a la strcoll)
 * \param astr string to compare to
 * \param bstr Other string
 * \return int - 0 is identical, -1 or 1 for difference.
 */
int
ansi_strcmp(const char *astr, const char *bstr)
{
  const char *a, *b;

  for (a = astr, b = bstr; *a && *b;) {
    a = skip_leading_ansi(a);
    b = skip_leading_ansi(b);
    if (*a != *b)
      return (*a - *b);
    if (*b)
      b++;
    if (*a)
      a++;
  }
  if (*a)
    a = skip_leading_ansi(a);
  if (*b)
    b = skip_leading_ansi(b);
  return (*a - *b);
}

/** Compare ansi_data for exact equality.
 * \param a ansi_data to compare
 * \param b other ansi_data
 * \return int - 1 is identical, 0 is different
 */
int
ansi_equal(const ansi_data a, const ansi_data b)
{
  return ((a.bits == b.bits) && (a.offbits == b.offbits) &&
          (a.fore == b.fore) && (a.back == b.back));
}

/** Return true if ansi_data contains no ansi values.
 * \param a ansi_data to check
 * \return int 1 on ansi_null, 0 otherwise
 */
int
ansi_isnull(const ansi_data a)
{
  return ((a.bits == 0) && (a.offbits == 0) && (a.fore == 0) && (a.back == 0));
}

/** Strip all ANSI and HTML markup from a string. As a side effect,
 * stores the length of the stripped string in a provided address.
 * NOTE! Length returned is length *including* the terminating NULL,
 * because we usually memcpy the result.
 * \param orig string to strip.
 * \param s_len address to store length of stripped string, if provided.
 * \return pointer to static buffer containing stripped string.
 */
char *
remove_markup(const char *orig, size_t * s_len)
{
  static char buff[BUFFER_LEN];
  char *bp = buff;
  const char *q;
  size_t len = 0;

  if (!orig) {
    if (s_len)
      *s_len = 0;
    return NULL;
  }

  for (q = orig; *q;) {
    switch (*q) {
    case ESC_CHAR:
      /* Skip over ansi */
      while (*q && *q++ != 'm') ;
      break;
    case TAG_START:
      /* Skip over HTML */
      while (*q && *q++ != TAG_END) ;
      break;
    default:
      safe_chr(*q++, buff, &bp);
      len++;
    }
  }
  *bp = '\0';
  if (s_len)
    *s_len = len + 1;
  return buff;
}

static char ansi_chars[50];
static int ansi_codes[255];

#define BUILD_ANSI(letter,ESCcode) \
do { \
  ansi_chars[ESCcode] = letter; \
  ansi_codes[(unsigned char) letter] = ESCcode; \
} while (0)

/** Set up the table of ansi codes */
void
init_ansi_codes(void)
{
  memset(ansi_chars, 0, sizeof(ansi_chars));
  memset(ansi_codes, 0, sizeof(ansi_codes));
/*
  BUILD_ANSI('n', COL_NORMAL);
  BUILD_ANSI('f', COL_FLASH);
  BUILD_ANSI('h', COL_HILITE);
  BUILD_ANSI('i', COL_INVERT);
  BUILD_ANSI('u', COL_UNDERSCORE);
*/
  BUILD_ANSI('x', COL_BLACK);
  BUILD_ANSI('X', COL_BLACK + 10);
  BUILD_ANSI('r', COL_RED);
  BUILD_ANSI('R', COL_RED + 10);
  BUILD_ANSI('g', COL_GREEN);
  BUILD_ANSI('G', COL_GREEN + 10);
  BUILD_ANSI('y', COL_YELLOW);
  BUILD_ANSI('Y', COL_YELLOW + 10);
  BUILD_ANSI('b', COL_BLUE);
  BUILD_ANSI('B', COL_BLUE + 10);
  BUILD_ANSI('m', COL_MAGENTA);
  BUILD_ANSI('M', COL_MAGENTA + 10);
  BUILD_ANSI('c', COL_CYAN);
  BUILD_ANSI('C', COL_CYAN + 10);
  BUILD_ANSI('w', COL_WHITE);
  BUILD_ANSI('W', COL_WHITE + 10);
}

#undef BUILD_ANSI

/** Write an internal markup tag for an ansi_data.
 * \param cur the ansi_data to write
 * \param buff buffer to write to
 * \param bp pointer to buff to write at
 * \retval number of chars written
 */
int
write_ansi_data(ansi_data *cur, char *buff, char **bp)
{
  int retval = 0;
  retval += safe_chr(TAG_START, buff, bp);
  retval += safe_chr(MARKUP_COLOR, buff, bp);
  retval += write_ansi_letters(cur, buff, bp);
  retval += safe_chr(TAG_END, buff, bp);
  return retval;
}

/** Write a closing internal markup tag for color.
 * \param buff buffer to write to
 * \param bp pointer to buff to write at
 */
int
write_ansi_close(char *buff, char **bp)
{
  int retval = 0;
  retval += safe_chr(TAG_START, buff, bp);
  retval += safe_chr(MARKUP_COLOR, buff, bp);
  retval += safe_chr('/', buff, bp);
  retval += safe_chr(TAG_END, buff, bp);
  return retval;
}

static int
write_ansi_letters(const ansi_data *cur, char *buff, char **bp)
{
  int retval = 0;
  char *save;
  save = *bp;
  if (cur->fore == 'n') {
    retval += safe_chr(cur->fore, buff, bp);
  } else {
#define CBIT_SET(x,y) (x->bits & y)
    if (CBIT_SET(cur, CBIT_FLASH))
      retval += safe_chr('f', buff, bp);
    if (CBIT_SET(cur, CBIT_HILITE))
      retval += safe_chr('h', buff, bp);
    if (CBIT_SET(cur, CBIT_INVERT))
      retval += safe_chr('i', buff, bp);
    if (CBIT_SET(cur, CBIT_UNDERSCORE))
      retval += safe_chr('u', buff, bp);
#undef CBIT_SET
#define CBIT_SET(x,y) (x->offbits & y)
    if (CBIT_SET(cur, CBIT_FLASH))
      retval += safe_chr('F', buff, bp);
    if (CBIT_SET(cur, CBIT_HILITE))
      retval += safe_chr('H', buff, bp);
    if (CBIT_SET(cur, CBIT_INVERT))
      retval += safe_chr('I', buff, bp);
    if (CBIT_SET(cur, CBIT_UNDERSCORE))
      retval += safe_chr('U', buff, bp);
#undef CBIT_SET

    if (cur->fore)
      retval += safe_chr(cur->fore, buff, bp);
    if (cur->back)
      retval += safe_chr(cur->back, buff, bp);
  }

  if (retval)
    *bp = save;
  return retval;
}


void
nest_ansi_data(ansi_data *old, ansi_data *cur)
{
  if (cur->fore != 'n') {
    cur->bits |= old->bits;
    cur->bits &= ~cur->offbits;
    if (!cur->fore)
      cur->fore = old->fore;
    if (!cur->back)
      cur->back = old->back;
  } else {
    cur->bits = 0;
    cur->offbits = 0;
    cur->back = 0;
  }
}

/* We need EDGE_UP to return 1 if x has bit set and y doesn't. */
#define EDGE_UP(x,y,z) (((x).bits & (z)) != ((y)->bits & (z)))
int
write_raw_ansi_data(ansi_data *old, ansi_data *cur, char *buff, char **bp)
{
  int f = 0;
  ansi_data past = *old;
  ansi_data pres = *cur;
  /* This shouldn't happen */
  if (pres.fore == 'n') {
    if (past.bits || (past.fore != 'n') || past.back) {
      return safe_str(ANSI_RAW_NORMAL, buff, bp);
    }
  }
  if (pres.fore == 'd')
    pres.fore = 0;
  if (pres.back == 'D')
    pres.back = 0;

  /* Do we *unset* anything in cur? */
  if ((past.bits & ~(pres.bits)) ||
      (past.fore && !pres.fore) || (past.back && !pres.back)) {
    safe_str(ANSI_RAW_NORMAL, buff, bp);
    past = ansi_null;
  }

  if (past.fore == pres.fore && past.back == pres.back &&
      past.bits == pres.bits)
    return 0;

  if (!(pres.fore || pres.back || pres.bits)) {
    if (past.fore != 'n')
      return safe_str(ANSI_RAW_NORMAL, buff, bp);
    return 0;
  }

  safe_str(ANSI_BEGIN, buff, bp);

#define maybe_append_code(code) \
  do { \
    if (EDGE_UP(past, cur, CBIT_ ## code)) {	\
      if (f++)				  \
	safe_chr(';', buff, bp);	  \
      safe_integer(COL_ ## code, buff, bp); \
    } \
  } while (0)

  maybe_append_code(HILITE);
  maybe_append_code(INVERT);
  maybe_append_code(FLASH);
  maybe_append_code(UNDERSCORE);

#undef maybe_append_code

  if (pres.fore && pres.fore != past.fore) {
    if (f++)
      safe_chr(';', buff, bp);
    safe_integer(ansi_codes[(unsigned char) pres.fore], buff, bp);
  }
  if (pres.back && pres.back != past.back) {
    if (f)
      safe_chr(';', buff, bp);
    safe_integer(ansi_codes[(unsigned char) pres.back], buff, bp);
  }

  return safe_str(ANSI_FINISH, buff, bp);
}

#undef EDGE_UP

void
define_ansi_data(ansi_data *store, const char *str)
{
  *store = ansi_null;

  for (; str && *str && (*str != TAG_END); str++) {
    switch (*str) {
    case 'n':                  /* normal */
      /* This is explicitly normal, it'll never be colored */
      store->bits = 0;
      store->offbits = ~0;
      store->fore = 'n';
      store->back = 0;
      break;
    case 'f':                  /* flash */
      store->bits |= CBIT_FLASH;
      store->offbits &= ~CBIT_FLASH;
      break;
    case 'h':                  /* hilite */
      store->bits |= CBIT_HILITE;
      store->offbits &= ~CBIT_HILITE;
      break;
    case 'i':                  /* inverse */
      store->bits |= CBIT_INVERT;
      store->offbits &= ~CBIT_INVERT;
      break;
    case 'u':                  /* underscore */
      store->bits |= CBIT_UNDERSCORE;
      store->offbits &= ~CBIT_UNDERSCORE;
      break;
    case 'F':                  /* flash */
      store->offbits |= CBIT_FLASH;
      break;
    case 'H':                  /* hilite */
      store->offbits |= CBIT_HILITE;
      break;
    case 'I':                  /* inverse */
      store->offbits |= CBIT_INVERT;
      break;
    case 'U':                  /* underscore */
      store->offbits |= CBIT_UNDERSCORE;
      break;
    case 'b':                  /* blue fg */
    case 'c':                  /* cyan fg */
    case 'g':                  /* green fg */
    case 'm':                  /* magenta fg */
    case 'r':                  /* red fg */
    case 'w':                  /* white fg */
    case 'x':                  /* black fg */
    case 'y':                  /* yellow fg */
    case 'd':                  /* default fg */
      store->fore = *str;
      break;
    case 'B':                  /* blue bg */
    case 'C':                  /* cyan bg */
    case 'G':                  /* green bg */
    case 'M':                  /* magenta bg */
    case 'R':                  /* red bg */
    case 'W':                  /* white bg */
    case 'X':                  /* black bg */
    case 'Y':                  /* yellow bg */
    case 'D':                  /* default fg */
      store->back = *str;
      break;
    }
  }
  store->bits &= ~(store->offbits);
}

int
read_raw_ansi_data(ansi_data *store, const char *codes)
{
  int curnum;
  if (!codes || !store)
    return 0;
  store->bits = 0;
  store->offbits = 0;
  store->fore = 0;
  store->back = 0;

  /* 'codes' can point at either the ESC_CHAR,
   * the '[', or the following byte. */

  /* Skip to the first ansi number */
  while (*codes && !isdigit((unsigned char) *codes) && *codes != 'm')
    codes++;

  while (*codes && (*codes != 'm')) {
    curnum = atoi(codes);
    if (curnum < 10) {
      switch (curnum) {
      case COL_HILITE:
        store->bits |= CBIT_HILITE;
        store->offbits &= ~CBIT_HILITE;
        break;
      case COL_UNDERSCORE:
        store->bits |= CBIT_UNDERSCORE;
        store->offbits &= ~CBIT_UNDERSCORE;
        break;
      case COL_FLASH:
        store->bits |= CBIT_FLASH;
        store->offbits &= ~CBIT_FLASH;
        break;
      case COL_INVERT:
        store->bits |= CBIT_INVERT;
        store->offbits &= ~CBIT_INVERT;
        break;
      case COL_NORMAL:
        store->bits = 0;
        store->offbits = ~0;
        store->fore = 'n';
        store->back = 0;
        break;
      }
    } else if (curnum < 40) {
      store->fore = ansi_chars[curnum];
    } else if (curnum < 50) {
      store->back = ansi_chars[curnum];
    }
    /* Skip current and find the next ansi number */
    while (*codes && isdigit((unsigned char) *codes))
      codes++;
    while (*codes && !isdigit((unsigned char) *codes) && (*codes != 'm'))
      codes++;
  }
  return 1;
}

/** Return a string pointer past any ansi/html markup at the start.
 * \param p a string.
 * \return pointer to string after any initial ansi/html markup.
 */

char *
skip_leading_ansi(const char *p)
{
  if (!p)
    return NULL;
  while (*p == ESC_CHAR || *p == TAG_START) {
    if (*p == ESC_CHAR) {
      while (*p && *p != 'm')
        p++;
    } else {                    /* TAG_START */
      while (*p && *p != TAG_END)
        p++;
    }
    if (*p)
      p++;
  }
  return (char *) p;

}

int
has_markup(const char *test)
{
  /* strtok modifies, so we don't use it. */
  return (strchr(test, ESC_CHAR)
          || strchr(test, TAG_START)
          || strchr(test, TAG_END));
}

static char *
parse_tagname(const char *ptr)
{
  static char tagname[BUFFER_LEN];
  char *tag = tagname;
  if (!ptr || !*ptr)
    return NULL;
  while (*ptr && !isspace((unsigned char) *ptr) && *ptr != TAG_END) {
    *(tag++) = *(ptr++);
  }
  *tag = '\0';
  return tagname;
}

static const char *
as_get_tag(ansi_string *as, const char *tag)
{
  if (!tag)
    return NULL;

  if (*tag == '/' && *(tag + 1) == '\0') {
    return "/";
  }
  if (as->tags == NULL) {
    as->tags = mush_malloc(sizeof(StrTree), "ansi_string.tags");
    st_init(as->tags, "ansi_string.tags");
  }
  return st_insert(tag, as->tags);
}

/** Make sure an ansi_string has room for one more markup_information, and
 *  return its index. */
static new_markup_information *
grow_mi(ansi_string *as, char type)
{
  if (as->micount >= as->misize) {
    if (as->mi == NULL) {
      as->misize = 30;
      as->mi = mush_malloc(as->misize * sizeof(new_markup_information),
                           "ansi_string.mi");
    } else {
      as->misize *= 2;
      as->mi = mush_realloc(as->mi,
                            as->misize * sizeof(new_markup_information),
                            "ansi_string.mi");
    }
  }
  memset(&as->mi[as->micount], 0, sizeof(new_markup_information));
  as->mi[as->micount].parentIdx = NOMARKUP;
  as->mi[as->micount].idx = as->micount;
  as->mi[as->micount].type = type;
  return &as->mi[as->micount++];
}

static inline new_markup_information *
MI_FOR(ansi_string *as, int idx)
{
  if (idx < 0 || idx > as->misize)
    return NULL;
  else
    return &as->mi[idx];
}

#define DOFREE_START   0x01
#define DOFREE_END     0x02

static char *colend = "/";

/** Convert a string into an ansi_string.
 * This takes a string that may contain ansi/html markup codes and
 * converts it to an ansi_string structure that separately stores
 * the plain string and the markup codes for each character.
 * \param source string to parse.
 * \return pointer to an ansi_string structure representing the src string.
 */
ansi_string *
parse_ansi_string(const char *source)
{
  ansi_string *as = mush_malloc(sizeof(ansi_string), "ansi_string");
  int c;
  char *s;
  char *tag, type;
  int len;

  /* For stacking information. */
  new_markup_information *mi = NULL;
  new_markup_information *mip = NULL;
  int idx = NOMARKUP;
  int pidx = NOMARKUP;

  /* Zero it out. */
  memset(as, 0, sizeof(ansi_string));

  if (!source) {
    return NULL;
  }

  /* Quick check for no markup */
  if (!has_markup(source)) {
    as->len = strlen(source);
    if (as->len >= BUFFER_LEN - 1) {
      as->len = BUFFER_LEN - 1;
    }
    strncpy(as->text, source, as->len);
    return as;
  }
  as->source = mush_strdup(source, "ansi_string.source");

  /* The string has markup. Nuts. */
  as->flags |= AS_HAS_MARKUP;
  as->markup = mush_malloc(sizeof(uint16_t) * BUFFER_LEN, "ansi_string.markup");

  c = 0;
  for (s = as->source; *s;) {
    switch (*s) {
    case TAG_START:
      s++;
      tag = s;
      while (*s && *s != TAG_END) {
        s++;
      }
      if (*s)
        *(s++) = '\0';

      /* <tag> contains the entire tag, now. */
      if (!*tag)
        break;
      type = *(tag++);
      if (!*tag)
        break;
      switch (type) {
      case MARKUP_COLOR:
        if (*tag != '/') {
          /* Start tag */
          pidx = idx;
          mi = grow_mi(as, MARKUP_COLOR);
          mi->start_code = as_get_tag(as, tag);
          mi->end_code = colend;
          mi->parentIdx = pidx;
          idx = mi->idx;
        } else {
          /* End tag */
          if (*(tag + 1) == 'a') {
            if (AS_HasTags(as)) {
              /* Color endall in a pueblo tag. Blah, we should
               * never see this in actual use. So let's just pretend
               * it's an end-all-tags until somebody complains. */
            }
            mi = NULL;
            idx = NOMARKUP;
          } else {
            if (mi) {
              /* Close all tags above the latest color tag and mark them
               * as standalone. Anybody who complains about it closing
               * overlapping pueblo tags can learn how to code nicely. The only
               * time this should close non-color tags is when they do
               * something silly like:
               *
               *   ansi(r,foo[tag(SAMP)]bar) hello [ansi(g,tag(/SAMP))].
               *
               * Use of tagwrap and responsible use of tag means this
               * won't happen. */
              for (; mi && mi->type != MARKUP_COLOR;
                   mi = MI_FOR(as, mi->parentIdx)) {
                mi->end_code = NULL;
                mi->standalone = 1;
                as->flags |= AS_HAS_STANDALONE;
              }
              if (mi) {
                idx = mi->parentIdx;
                mi = MI_FOR(as, idx);
              }
            }
          }
        }
        break;
      default:
        if (*tag != '/') {
          /* Start tag */
          as->flags |= AS_HAS_TAGS;
          pidx = idx;
          mi = grow_mi(as, type);
          mi->start_code = as_get_tag(as, tag);
          mi->parentIdx = pidx;
          mi->start = c;
          idx = mi->idx;
        } else {
          /* End tag */
          if (mi) {
            tag++;
            len = strlen(tag);
            /* Find the tag that this closes. */
            for (mip = mi; mip; mip = MI_FOR(as, mip->parentIdx)) {
              if ((mip->type == type) &&
                  (!strncasecmp(mip->start_code, tag, len)) &&
                  ((mip->start_code[len] == ' ') ||
                   (mip->start_code[len] == '\0'))) {
                break;
              }
            }
            if (mip) {
              /* Close the stack of stuff above mip. All non-'c' types
               * are standalones. all C types are force-closed. Because,
               * y'know, people really shouldn't be using overlapping
               * tags. */
              for (; mi != mip; mi = MI_FOR(as, mi->parentIdx)) {
                if (mi->type != MARKUP_COLOR) {
                  mi->end_code = NULL;
                  mi->standalone = 1;
                  as->flags |= AS_HAS_STANDALONE;
                }
              }
              tag--;
              mip->end_code = as_get_tag(as, tag);
              idx = mip->parentIdx;
              mi = MI_FOR(as, idx);
            } else {
              /* Yes, goto is useful here. Yes it is. Shut up, it is. */
              goto standalone_end;
            }
          } else {
          standalone_end:
            /* Standalone end tag?! Lame. We turn it into a start tag
             * and attach it to the next character. */
            as->flags |= AS_HAS_TAGS;
            as->flags |= AS_HAS_STANDALONE;
            pidx = idx;
            mi = grow_mi(as, type);
            mi->end_code = mi->start_code = as_get_tag(as, tag);
            mi->parentIdx = pidx;
            mi->start = c;
            mi->standalone = 1;
            idx = mi->idx;
          }
        }
        break;
      case '\0':
        /* Do nothing: Empty tag?! We'll shove it under the carpet
         * and forget about it. */
        break;
      }
      break;
    case ESC_CHAR:
      /* Here's what I'm going to do: An ESC_CHAR is an old escape code,
       * so we'll treat it as if it's a standalone tag. It's a MARKUP_OLDANSI
       * tag, which receives special handling. */
      pidx = idx;
      mi = grow_mi(as, MARKUP_OLDANSI);
      *(s++) = '\0';
      mi->start_code = s;
      mi->standalone = 1;
      /* Find the end of the ansi code, or series of ansi codes. */
      while (*s) {
        if (*s == 'm' && *(s + 1) != ESC_CHAR)
          break;
        s++;
      }
      if (*s)
        *(s++) = '\0';
      mi->start_code = as_get_tag(as, mi->start_code);
      mi->end_code = NULL;
      mi->parentIdx = pidx;
      idx = mi->idx;
      break;
    default:
      as->text[c] = *s;
      as->markup[c] = idx;
      c++;
      s++;
      while (idx >= 0 && as->mi[idx].standalone) {
        idx = as->mi[idx].parentIdx;
      }
      mi = MI_FOR(as, idx);
    }
  }
  as->len = c;
  if (mi) {
    for (; mi; mi = MI_FOR(as, mi->parentIdx)) {
      if (mi->type != MARKUP_COLOR) {
        /* Turn this tag into a standalone. */
        mi->standalone = 1;
        as->flags |= AS_HAS_STANDALONE;
      }
    }
  }
  if (as->flags & AS_HAS_STANDALONE ||
      (as->mi && as->mi[as->micount - 1].start == as->len)) {
    /* If there are any markup tags at the very end (start == as->len),
     * then we have to move them forward, change start to end code, and
     * advance them. Unless length is 0, in which case the only thing this
     * string has is a standalone tag. Ew.  */
    if (as->len > 0) {
      if (as->mi[as->micount - 1].start == as->len) {
        /* Attach to the last character's markup. */
        pidx = as->markup[as->len - 1];
        for (idx = pidx + 1; idx < as->micount; idx++) {
          if (as->mi[idx].start == as->len && as->mi[idx].type != MARKUP_COLOR) {
            as->flags |= AS_HAS_STANDALONE;
            as->mi[idx].end_code = as->mi[idx].start_code;
            as->mi[idx].start_code = NULL;
            as->mi[idx].standalone = 1;
            pidx = idx;
          }
        }
        as->markup[as->len - 1] = pidx;
      }
    }
  }
  return as;
}

/** Free an ansi_string.
 * \param as pointer to ansi_string to free.
 */
void
free_ansi_string(ansi_string *as)
{
  if (!as)
    return;

  if (as->source) {
    mush_free(as->source, "ansi_string.source");
  }
  if (as->tags) {
    st_flush(as->tags);
    mush_free(as->tags, "ansi_string.tags");
  }
  if (as->markup) {
    mush_free(as->markup, "ansi_string.markup");
  }
  if (as->mi) {
    mush_free(as->mi, "ansi_string.mi");
  }

  mush_free(as, "ansi_string");
}

/* Copy the start code for a particular markup_info */
static int
safe_start_code(new_markup_information *info, char *buff, char **bp)
{
  int retval = 0;
  char *save;
  save = *bp;
  if (info && info->start_code) {
    if (info->type == MARKUP_OLDANSI) {
      retval += safe_chr(ESC_CHAR, buff, bp);
      retval += safe_str(info->start_code, buff, bp);
      retval += safe_chr('m', buff, bp);
    } else {
      retval += safe_chr(TAG_START, buff, bp);
      retval += safe_chr(info->type, buff, bp);
      retval += safe_str(info->start_code, buff, bp);
      retval += safe_chr(TAG_END, buff, bp);
    }
  }
  if (retval)
    *bp = save;
  return retval;
}

/* Copy the stop code for a particular markup_info */
static int
safe_end_code(new_markup_information *info, char *buff, char **bp)
{
  int retval = 0;
  char *save;
  save = *bp;
  if (info && info->end_code) {
    if (info->type == MARKUP_OLDANSI) {
      retval += safe_chr(ESC_CHAR, buff, bp);
      retval += safe_str(info->end_code, buff, bp);
      retval += safe_chr('m', buff, bp);
    } else {
      retval += safe_chr(TAG_START, buff, bp);
      retval += safe_chr(info->type, buff, bp);
      retval += safe_str(info->end_code, buff, bp);
      retval += safe_chr(TAG_END, buff, bp);
    }
  }
  if (retval)
    *bp = save;
  return retval;
}

/** Reverse an ansi string, preserving its ansification.
 * This function destructively modifies the ansi_string passed.
 * \param as pointer to an ansi string.
 */
void
flip_ansi_string(ansi_string *as)
{
  int s;
  int e;
  char tmp;
  uint16_t mitmp;

  for (s = 0, e = as->len - 1; s < e; s++, e--) {
    tmp = as->text[s];
    as->text[s] = as->text[e];
    as->text[e] = tmp;
    if (as->markup) {
      mitmp = as->markup[s];
      as->markup[s] = as->markup[e];
      as->markup[e] = mitmp;
    }
  }
}

/** Delete a portion of an ansi string.
 * \param as ansi_string to delete from
 * \param start start point to remove
 * \param count length of string to remove
 * \retval 0 success
 * \retval 1 failure.
 */
int
ansi_string_delete(ansi_string *as, int start, int count)
{
  int s, c, l;
  int i;
  if (count < 1)
    return 0;
  if (start > as->len)
    return 1;
  if ((start + count) > as->len) {
    count = (as->len - start);
  }
  if (count < 1)
    return 1;
  /* Move text left */
  s = start;
  c = start + count;
  l = as->len - c;
  memmove(as->text + s, as->text + c, l);
  /* Move markup left. */
  if (as->markup) {
    l *= sizeof(uint16_t);
    memmove(as->markup + s, as->markup + c, l);
  }
  if (as->flags & AS_HAS_STANDALONE) {
    /* If we have standalone markup, move the start. */
    for (i = 0; i < as->micount; i++) {
      if (as->mi[i].start > c) {
        as->mi[i].start -= count;
      }
    }
  }
  as->len -= count;
  as->text[as->len] = '\0';
  return 0;
}

/** Insert an ansi string into another ansi_string
 * with markups kept as straight as possible.
 * \param dst ansi_string to insert into.
 * \param loc Location to insert into, 0-indexed
 * \param src ansi_string to insert
 * \retval 0 success
 * \retval 1 failure.
 */
int
ansi_string_insert(ansi_string *dst, int loc, ansi_string *src)
{
  return ansi_string_replace(dst, loc, 0, src);
}

/** Replace a portion of an ansi string with
 *  another ansi string, keeping markups as
 *  straight as possible.
 * \param dst ansi_string to insert into.
 * \param loc Location to  insert into, 0-indexed
 * \param count Length of string inside dst to replace
 * \param src ansi_string to insert
 * \retval 0 success
 * \retval 1 failure.
 */
int
ansi_string_replace(ansi_string *dst, int loc, int count, ansi_string *src)
{
  int len, oldlen, srclen, srcend, dstleft;
  int idx, sidx, baseidx;
  int i, j;
  int truncated = 0;
  new_markup_information *basemi, *mis, *mi, *mie;

  oldlen = dst->len;
  srclen = src->len;

  if (loc > oldlen) {
    /* If the dst string isn't long enough, we don't replace, we just
     * insert at the end of the existing string */
    loc = dst->len;
    count = 0;
  }

  if (loc + count > oldlen)
    count = oldlen - loc;

  srcend = loc + srclen;
  len = oldlen + srclen;

  dstleft = oldlen - (loc + count);
  len -= count;

  if (len >= BUFFER_LEN) {
    if (loc >= BUFFER_LEN - 1) {
      return 1;
    }
    len = BUFFER_LEN - 1;
    truncated = 1;
    if (srcend >= BUFFER_LEN) {
      srclen = len - loc;
      dstleft = 0;
    } else {
      dstleft = len - srcend;
    }
  }

  /* Nothing to copy? */
  if (src->len < 1) {
    if (count > 0) {
      ansi_string_delete(dst, loc, count);
    }
    if (src->markup && src->flags & AS_HAS_STANDALONE) {
      dst->flags |= AS_HAS_STANDALONE;
      /* Special case: src has only standalone tags. */
      if (!dst->markup) {
        dst->markup = mush_malloc(sizeof(uint16_t) * BUFFER_LEN,
                                  "ansi_string.markup");
        for (i = 0; i < dst->len; i++) {
          dst->markup[i] = NOMARKUP;
        }
        dst->flags |= AS_HAS_MARKUP;
      }
      /* Add the incoming markup, but only the standalone. */
      baseidx = NOMARKUP;
      idx = NOMARKUP;
      for (sidx = 0; sidx < src->micount; sidx++) {
        if (!src->mi[sidx].standalone)
          continue;
        mi = grow_mi(dst, src->mi[sidx].type);
        mi->start_code = as_get_tag(dst, src->mi[sidx].start_code);
        mi->end_code = as_get_tag(dst, src->mi[sidx].end_code);
        mi->standalone = 1;
        mi->start = loc;

        mi->parentIdx = idx;
        if (baseidx < 0)
          baseidx = mi->idx;
        idx = mi->idx;
      }
      /* Now integrate them into the proper location */
      if (baseidx >= 0) {
        if (loc <= (dst->len - 1)) {
          /* Add the incoming markup to the character at dst->markup[loc] */
          dst->mi[baseidx].parentIdx = dst->markup[loc];
          dst->markup[loc] = idx;
        } else if (dst->len > 0) {
          dst->mi[baseidx].parentIdx = dst->markup[dst->len - 1];
          dst->markup[dst->len - 1] = idx;
          /* Now ensure all start tags are end tags */
          while (baseidx <= idx) {
            if (dst->mi[baseidx].start_code) {
              dst->mi[baseidx].end_code = dst->mi[baseidx].start_code;
              dst->mi[baseidx].start_code = NULL;
            }
            baseidx++;
          }
        }
      }
      return 0;
      /* If dst->len == 0, then it's just an empty string with standalone
       * markup. */
    } else {
      return 0;
    }
  }
  /* If we don't have anything to copy, then return. */
  if (srclen < 1) {
    return 1;
  }

  /* Move the text over. */
  if (dstleft > 0) {
    memmove(dst->text + srcend, dst->text + loc + count, dstleft);
  }

  /* Copy src over */
  memcpy(dst->text + loc, src->text, srclen);
  dst->len = len;
  dst->text[len] = '\0';

  /* If there's no markup, we're done. */
  if (!(src->markup || dst->markup)) {
    return truncated;
  }

  /* In case of copying from marked up string to non-marked-up. */
  if (!dst->markup) {
    dst->markup = mush_malloc(sizeof(uint16_t) * BUFFER_LEN,
                              "ansi_string.markup");
    for (i = 0; i < len; i++) {
      dst->markup[i] = NOMARKUP;
    }
    dst->flags |= AS_HAS_MARKUP;
  }
  if (!src->markup) {
    src->markup = mush_malloc(sizeof(uint16_t) * BUFFER_LEN,
                              "ansi_string.markup");
    for (i = 0; i < srclen; i++) {
      src->markup[i] = NOMARKUP;
    }
    src->flags |= AS_HAS_MARKUP;
  }

  /* Save the markup info pointers for loc and loc-1 */
  mis = NULL;
  mie = NULL;
  if (count == 0) {
    if (loc > 0 && dst->markup[loc - 1] >= 0) {
      if (dst->markup[loc] >= 0)
        mis = &dst->mi[dst->markup[loc - 1]];
    }
    if (dst->markup[loc] >= 0) {
      if (dst->markup[loc] >= 0)
        mie = &dst->mi[dst->markup[loc]];
    }
  } else {
    i = loc;
    if (i <= oldlen) {
      if (dst->markup[i] >= 0)
        mis = &dst->mi[dst->markup[i]];
    }
    i = loc + count - 1;
    if (i <= oldlen) {
      if (dst->markup[i] >= 0)
        mie = &dst->mi[dst->markup[i]];
    }
  }

  /* Move markup as necessary. */
  if (dstleft > 0) {
    memmove(dst->markup + srcend,
            dst->markup + (loc + count), dstleft * sizeof(int16_t));
  }

  /* If, and only if, mis and mie have a markup_information in common,
   * use that as basemi for the _entire_ inserted string. */
  basemi = NULL;
  if (mis && mie) {
    while (mie) {
      basemi = mis;
      while (basemi) {
        if (basemi->idx == mie->idx) {
          break;
        }
        basemi = MI_FOR(dst, basemi->parentIdx);
      }
      if (basemi)
        break;
      mie = MI_FOR(dst, mie->parentIdx);
    }
    /* basemi is either NULL or set at this point. */
  }
  baseidx = NOMARKUP;
  if (basemi) {
    baseidx = basemi->idx;
  }

  /* Copy the markup info of src over. */
  idx = dst->micount;
  for (sidx = 0; sidx < src->micount; sidx++) {
    mi = grow_mi(dst, src->mi[sidx].type);
    mi->start_code = as_get_tag(dst, src->mi[sidx].start_code);
    mi->end_code = as_get_tag(dst, src->mi[sidx].end_code);
    mi->standalone = src->mi[sidx].standalone;
    mi->start = src->mi[sidx].start + loc;
    if (src->mi[sidx].parentIdx >= 0) {
      mi->parentIdx = src->mi[sidx].parentIdx + idx;
    } else {
      mi->parentIdx = baseidx;
    }
  }

  /* Copy src's markup over, updating to new idx. */
  if (src->markup) {
    memcpy(dst->markup + loc, src->markup, srclen * sizeof(uint16_t));
    for (i = loc, j = 0; i < srcend; i++, j++) {
      if (src->markup[j] >= 0) {
        dst->markup[i] = src->markup[j] + idx;
      } else {
        dst->markup[i] = baseidx;
      }
    }
  } else {
    for (i = loc; i < srcend; i++) {
      dst->markup[i] = baseidx;
    }
  }
  return truncated;
}


/** Scrambles an ansi_string in place.
 */
void
scramble_ansi_string(ansi_string *as)
{
  int i, j;
  char tmp;
  uint16_t idxtmp;

  for (i = 0; i < as->len; i++) {
    j = get_random32(0, as->len - 1);
    tmp = as->text[i];
    as->text[i] = as->text[j];
    as->text[j] = tmp;
    if (as->markup) {
      idxtmp = as->markup[i];
      as->markup[i] = as->markup[j];
      as->markup[j] = idxtmp;
    }
  }
}

/** Safely append markup tags onto a buffer
 * \param mi markup_information to write
 * \param end If true, end_code. Otherwise start_code.
 * \param buff buffer to write to
 * \param bp where to write to
 * \retval 0 safely written
 * \retval 1 unable to safely write.
 */
int
safe_markup_codes(new_markup_information *mi, int end, char *buff, char **bp)
{
  if (end) {
    if (mi->end_code)
      return safe_str(mi->end_code, buff, bp);
  } else {
    if (mi->start_code)
      return safe_str(mi->start_code, buff, bp);
  }
  return 0;
}

/** Safely append markup changes between one idx and the other
 * \param as the ansi string
 * \param lastidx idx to close
 * \param nextidx idx to open
 * \param buff buffer to write to
 * \param bp where to write to
 * \retval 0 safely written
 * \retval 1 unable to safely write.
 */
static int
safe_markup_change(ansi_string *as, int lastidx, int nextidx, int pos,
                   char *buff, char **bp)
{
  new_markup_information *lastmi, *nextmi;
  new_markup_information *mil = NULL, *mir = NULL;
  int i = 0;
  new_markup_information *endbuff[BUFFER_LEN];
  bool right_side = 0;

  if (lastidx >= 0) {
    lastmi = &as->mi[lastidx];
  } else {
    lastmi = NULL;
  }

  if (nextidx >= 0) {
    nextmi = &as->mi[nextidx];
  } else {
    nextmi = NULL;
  }

  /* dump closing tags for that which is in mil that isn't in mir. */
  /* Look for the highest mil that exists in mir. */
  for (mil = lastmi; mil; mil = MI_FOR(as, mil->parentIdx)) {
    for (mir = nextmi; mir; mir = MI_FOR(as, mir->parentIdx)) {
      if (mil == mir)
        break;
    }
    if (mir)
      break;
  }
  /* Dump the end codes for everything from lastmi down to mil. */
  for (; lastmi && lastmi != mil; lastmi = MI_FOR(as, lastmi->parentIdx)) {
    if (safe_end_code(lastmi, buff, bp))
      return 1;
  }
  /* Now we do the start codes for everything on the right. We have to
   * do this from the bottom of the stack (or rmi)-up, though. */
  for (i = 0;
       nextmi && nextmi != mir;
       nextmi = MI_FOR(as, nextmi->parentIdx), i += 1) {
    endbuff[i] = nextmi;
    right_side = 1;
  }
  if (right_side) {
    while (i--) {
      if (!(endbuff[i]->standalone && pos != endbuff[i]->start)) {
        if (safe_start_code(endbuff[i], buff, bp))
          return 1;
      }
    }
  }
  return 0;
}

/** Safely append an ansi_string into a buffer as a real string,
 * \param as pointer to ansi_string to append.
 * \param start position in as to start copying from.
 * \param len length in characters to copy from as.
 * \param buff buffer to insert into.
 * \param bp pointer to pointer to insertion point of buff.
 * \retval 0 success.
 * \retval 1 failure.
 */
int
safe_ansi_string(ansi_string *as, int start, int len, char *buff, char **bp)
{
  int i;
  int end;
  int retval = 0;
  int lastidx;
  char *buffend = buff + BUFFER_LEN;

  if (!as)
    return 0;

  if (start == 0 && as->len == 0 && (as->flags & AS_HAS_STANDALONE)) {
    for (i = 0; i < as->micount; i++) {
      if (!as->mi[i].standalone)
        continue;
      if (as->mi[i].start_code) {
        safe_start_code(&as->mi[i], buff, bp);
      }
      if (as->mi[i].end_code) {
        safe_end_code(&as->mi[i], buff, bp);
      }
    }
  }
  if ((start >= as->len) || (start < 0) || (len < 1)) {
  }

  if (start + len >= as->len) {
    len = (as->len - start);
  }

  /* Quick check: If no markup, no markup =). */
  if (!(as->flags & AS_HAS_MARKUP)) {
    return safe_strl(as->text + start, len, buff, bp);
  }

  end = start + len;

  lastidx = NOMARKUP;

  /* The string has markup. Let's dump it. */
  for (i = start; i < end;) {
    while (lastidx == as->markup[i] && (i < end) && ((*bp) < buffend)) {
      *((*bp)++) = as->text[i++];
    }
    if ((*bp) >= buffend) {
      return 1;
    }
    if (i < end) {
      if (lastidx != as->markup[i]) {
        if (safe_markup_change(as, lastidx, as->markup[i], i, buff, bp)) {
          return 1;
        }
        lastidx = as->markup[i];
      }
    } else if (lastidx != NOMARKUP) {
      if (safe_markup_change(as, lastidx, NOMARKUP, i, buff, bp)) {
        return 1;
      }
    }
  }
  return retval;
}

/* Following functions are used for
 * decompose_str()
 */

extern char escaped_chars[UCHAR_MAX + 1];

static int
escape_marked_str(char **str, char *buff, char **bp)
{
  unsigned char *in;
  int retval = 0;
  int dospace = 1;
  int spaces = 0;
  int i;

  if (!str || !*str || !**str)
    return 0;
  in = (unsigned char *) *str;
  for (; *in && *in != ESC_CHAR && *in != TAG_START; in++) {
    if (*in == ' ') {
      spaces++;
    } else {
      if (spaces) {
        if (spaces >= 5) {
          retval += safe_str("[space(", buff, bp);
          retval += safe_number(spaces, buff, bp);
          retval += safe_str(")]", buff, bp);
        } else {
          if (dospace) {
            spaces--;
            retval += safe_str("%b", buff, bp);
          }
          while (spaces) {
            retval += safe_chr(' ', buff, bp);
            if (--spaces) {
              --spaces;
              retval += safe_str("%b", buff, bp);
            }
          }
        }
      }
      spaces = 0;
      dospace = 0;
      switch (*in) {
      case '\n':
        retval += safe_str("%r", buff, bp);
        break;
      case '\t':
        retval += safe_str("%t", buff, bp);
        break;
      case BEEP_CHAR:
        for (i = 1; *(in + 1) == BEEP_CHAR && i < 5; in++, i++) ;
        retval += safe_format(buff, bp, "[beep(%d)]", i);
        break;
      default:
        if (escaped_chars[*in])
          retval += safe_chr('\\', buff, bp);
        retval += safe_chr(*in, buff, bp);
        break;
      }
    }
  }
  if (spaces) {
    if (spaces >= 5) {
      retval += safe_str("[space(", buff, bp);
      retval += safe_number(spaces, buff, bp);
      retval += safe_str(")]", buff, bp);
    } else {
      spaces--;                 /* This is for the final %b space */
      if (spaces && dospace) {
        spaces--;
        retval += safe_str("%b", buff, bp);
      }
      while (spaces) {
        safe_chr(' ', buff, bp);
        if (--spaces) {
          --spaces;
          retval += safe_str("%b", buff, bp);
        }
      }
      retval += safe_str("%b", buff, bp);
    }
  }
  *str = (char *) in;
  return retval;
}

/* Does the work of decompose_str, which is found in look.c.
 * Even handles ANSI and Pueblo, which is why it's so ugly.
 */
int
real_decompose_str(char *orig, char *buff, char **bp)
{
  int i;
  char *str = orig;
  char *tmp;
  char *pstr;
  char type;

  ansi_data ansistack[BUFFER_LEN];
  ansi_data oldansi;
  ansi_data tmpansi;
  int ansitop = 0;
  int ansiheight = 0;
  int howmanyopen = 0;
  int oldcodes = 0;

  char *pueblostack[BUFFER_LEN];
  char tagbuff[BUFFER_LEN];
  int pueblotop = -1;

  int retval = 0;

  ansistack[0] = ansi_null;

  if (!str || !*str)
    return 0;

  retval += escape_marked_str(&str, buff, bp);

  while (str && *str && *str != '\0') {
    oldansi = ansistack[ansitop];
    ansiheight = ansitop;
    while (*str == TAG_START || *str == ESC_CHAR) {
      switch (*str) {
      case TAG_START:
        for (tmp = str; *tmp && *tmp != TAG_END; tmp++) ;
        if (*tmp) {
          *tmp = '\0';
        } else {
          tmp--;
        }
        str++;
        type = *(str++);
        switch (type) {
        case MARKUP_COLOR:
          if (!*str)
            break;
          if (oldcodes == 1) {
            ansitop--;
            oldcodes = 0;
          }
          /* Start or end tag? */
          if (*str != '/') {
            define_ansi_data(&tmpansi, str);
            nest_ansi_data(&(ansistack[ansitop]), &tmpansi);
            ansitop++;
            ansistack[ansitop] = tmpansi;
          } else {
            if (*(str + 1) == 'a') {
              ansitop = 0;
            } else {
              if (ansitop > 0) {
                ansitop--;
              }
            }
          }
          break;
        case MARKUP_HTML:
          if (!*str)
            break;
          if (*str != '/') {
            pueblotop++;
            snprintf(tagbuff, BUFFER_LEN, "%s", parse_tagname(str));
            pueblostack[pueblotop] = mush_strdup(tagbuff, "markup_code");

            retval += safe_str("[tag(", buff, bp);
            retval += safe_str(tagbuff, buff, bp);
            str += strlen(tagbuff);
            if (str && *str) {
              while (str && str != tmp) {
                str++;
                pstr = strchr(str, '=');
                if (pstr) {
                  *pstr = '\0';
                  retval += safe_chr(',', buff, bp);
                  retval += safe_str(str, buff, bp);
                  retval += safe_chr('=', buff, bp);
                  str = pstr + 1;
                  pstr = strchr(str, '\"');

                  retval += safe_chr('\"', buff, bp);
                  if (str == pstr) {
                    str++;
                    pstr = strchr(str, '\"');
                  } else {
                    pstr = strchr(str, ' ');
                  }

                  if (!pstr)
                    pstr = tmp;

                  *pstr = '\0';
                  retval += safe_str(str, buff, bp);
                  retval += safe_chr('\"', buff, bp);
                  str = pstr;
                } else {
                  safe_str(str, buff, bp);
                  break;
                }
              }
            }
            retval += safe_str(")]", buff, bp);

          } else {
            if (pueblotop > -1) {
              i = (*(str + 1) == 'a') ? 0 : pueblotop;
              for (i--; pueblotop > i; pueblotop--) {
                retval += safe_str("[endtag(", buff, bp);
                retval += safe_str(pueblostack[pueblotop], buff, bp);
                retval += safe_str(")]", buff, bp);
                mush_free(pueblostack[pueblotop], "markup_code");
              }
            }
          }
          break;
        }
        tmp++;
        str = tmp;
        break;
      case ESC_CHAR:
        /* It SHOULD be impossible to get here... */
        for (tmp = str; *tmp && *tmp != 'm'; tmp++) ;

        /* Store the "background" colors */
        tmpansi = ansistack[ansitop];
        if (oldcodes == 0) {
          oldcodes = 1;
          ansitop++;
          ansistack[ansitop] = tmpansi;
          ansistack[ansitop].offbits = 0;
        }

        read_raw_ansi_data(&tmpansi, str);
        ansistack[ansitop].bits |= tmpansi.bits;
        ansistack[ansitop].bits &= ~(tmpansi.offbits);  /* ANSI_RAW_NORMAL */
        if (tmpansi.fore)
          ansistack[ansitop].fore = tmpansi.fore;
        if (tmpansi.back)
          ansistack[ansitop].back = tmpansi.back;

        str = tmp;
        if (*tmp)
          str++;
        break;
      }
    }

    /* Handle ANSI/Text */
    tmpansi = ansistack[ansitop];
    if (ansitop > 0 || ansiheight > 0) {
      /* Close existing tags as necessary to cleanly open the next. */
      /*  oldansi = ansistack[ansiheight]; */
      if (!ansi_equal(oldansi, tmpansi)) {
        while (ansiheight > 0) {
          if (howmanyopen > 0) {
            howmanyopen--;
            retval += safe_str(")]", buff, bp);
          }
          ansiheight--;
        }
      }
      if (!ansi_isnull(tmpansi) && !ansi_equal(oldansi, tmpansi)) {
        retval += safe_str("[ansi(", buff, bp);
        retval += write_ansi_letters(&tmpansi, buff, bp);
        retval += safe_chr(',', buff, bp);
        howmanyopen++;
      }
    }
    retval += escape_marked_str(&str, buff, bp);
  }

  for (; howmanyopen > 0; howmanyopen--)
    retval += safe_str(")]", buff, bp);
  for (; pueblotop > -1; pueblotop--) {
    retval += safe_str("[endtag(", buff, bp);
    retval += safe_str(pueblostack[pueblotop], buff, bp);
    retval += safe_str(")]", buff, bp);
  }

  return retval;
}

/** Our version of pcre_copy_substring, with ansi-safeness.
 * \param as the ansi_string whose .text value was matched against.
 * \param ovector the offset vectors
 * \param stringcount the number of subpatterns
 * \param stringnumber the number of the desired subpattern
 * \param nonempty if true, copy empty registers as well.
 * \param buff buffer to copy the subpattern to
 * \param bp pointer to the end of buffer
 * \return size of subpattern, or -1 if unknown pattern
 */
int
ansi_pcre_copy_substring(ansi_string *as, int *ovector,
                         int stringcount, int stringnumber,
                         int nonempty, char *buff, char **bp)
{
  int yield;
  if (stringnumber < 0 || stringnumber >= stringcount)
    return -1;
  stringnumber *= 2;
  yield = ovector[stringnumber + 1] - ovector[stringnumber];
  if (!nonempty || yield) {
    safe_ansi_string(as, ovector[stringnumber], yield, buff, bp);
    **bp = '\0';
  }
  return yield;
}


/** Our version of pcre_copy_named_substring, with ansi-safeness.
 * \param code the pcre compiled code
 * \param as the ansi_string whose .text value was matched against.
 * \param ovector the offset vectors
 * \param stringcount the number of subpatterns
 * \param stringname the name of the desired subpattern
 * \param ne if true, copy empty registers as well.
 * \param buff buffer to copy the subpattern to
 * \param bp pointer to the end of buffer
 * \return size of subpattern, or -1 if unknown pattern
 */
int
ansi_pcre_copy_named_substring(const pcre * code, ansi_string *as,
                               int *ovector, int stringcount,
                               const char *stringname, int ne,
                               char *buff, char **bp)
{
  int n = pcre_get_stringnumber(code, stringname);
  if (n <= 0)
    return -1;
  return ansi_pcre_copy_substring(as, ovector, stringcount, n, ne, buff, bp);
}

/** Safely add a tag into a buffer.
 * If we support pueblo, this function adds the tag start token,
 * the tag, and the tag end token. If not, it does nothing.
 * If we can't fit the tag in, we don't put any of it in.
 * \param a_tag the html tag to add.
 * \param buf the buffer to append to.
 * \param bp pointer to address in buf to insert.
 * \retval 0, successfully added.
 * \retval 1, tag wouldn't fit in buffer.
 */
static int
safe_markup(char const *a_tag, char *buf, char **bp, char type)
{
  int result;
  char *save = buf;
  safe_chr(TAG_START, buf, bp);
  safe_chr(type, buf, bp);
  safe_str(a_tag, buf, bp);
  result = safe_chr(TAG_END, buf, bp);
  /* If it didn't all fit, rewind. */
  if (result)
    *bp = save;
  return result;
}

int
safe_tag(char const *a_tag, char *buff, char **bp)
{
  if (SUPPORT_PUEBLO)
    return safe_markup(a_tag, buff, bp, MARKUP_HTML);
  return 0;
}

/** Safely add a closing tag into a buffer.
 * If we support pueblo, this function adds the tag start token,
 * a slash, the tag, and the tag end token. If not, it does nothing.
 * If we can't fit the tag in, we don't put any of it in.
 * \param a_tag the html tag to add.
 * \param buf the buffer to append to.
 * \param bp pointer to address in buf to insert.
 * \retval 0, successfully added.
 * \retval 1, tag wouldn't fit in buffer.
 */
static int
safe_markup_cancel(char const *a_tag, char *buf, char **bp, char type)
{
  int result;
  char *save = buf;
  safe_chr(TAG_START, buf, bp);
  safe_chr(type, buf, bp);
  safe_chr('/', buf, bp);
  safe_str(a_tag, buf, bp);
  result = safe_chr(TAG_END, buf, bp);
  /* If it didn't all fit, rewind. */
  if (result)
    *bp = save;
  return result;
}

int
safe_tag_cancel(char const *a_tag, char *buf, char **bp)
{
  if (SUPPORT_PUEBLO)
    return safe_markup_cancel(a_tag, buf, bp, MARKUP_HTML);
  return 0;
}

/** Safely add a tag, some text, and a matching closing tag into a buffer.
 * If we can't fit the stuff, we don't put any of it in.
 * \param a_tag the html tag to add.
 * \param params tag parameters.
 * \param data the text to wrap the tag around.
 * \param buf the buffer to append to.
 * \param bp pointer to address in buf to insert.
 * \param player the player involved in all this, or NOTHING if internal.
 * \retval 0, successfully added.
 * \retval 1, tagged text wouldn't fit in buffer.
 */
int
safe_tag_wrap(char const *a_tag, char const *params,
              char const *data, char *buf, char **bp, dbref player)
{
  int result = 0;
  char *save = buf;
  if (SUPPORT_PUEBLO) {
    safe_chr(TAG_START, buf, bp);
    safe_chr(MARKUP_HTML, buf, bp);
    safe_str(a_tag, buf, bp);
    if (params && *params && ok_tag_attribute(player, params)) {
      safe_chr(' ', buf, bp);
      safe_str(params, buf, bp);
    }
    safe_chr(TAG_END, buf, bp);
  }
  result = safe_str(data, buf, bp);
  if (SUPPORT_PUEBLO) {
    result = safe_tag_cancel(a_tag, buf, bp);
  }
  /* If it didn't all fit, rewind. */
  if (result)
    *bp = save;
  return result;
}
